### tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端

#### tcp服务端

```python
ss = socket() 					# 创建服务器套接字
ss.bind()      					# 把地址绑定到套接字
ss.listen()      				# 监听链接
inf_loop:      					# 服务器无限循环
    cs = ss.accept() 			# 接受客户端链接
    comm_loop:         			# 通讯循环
        cs.recv()/cs.send() 	# 对话(接收与发送)
    cs.close()    				# 关闭客户端套接字
ss.close()       			    # 关闭服务器套接字(可选)
```

#### Tcp客户端

```python
cs = socket()    				# 创建客户套接字
cs.connect()    				# 尝试连接服务器
comm_loop:        				# 通讯循环
    cs.send()/cs.recv()    		# 对话(发送/接收)
cs.close()           		    # 关闭客户套接字
```

### 两种情况下会发生粘包

> 发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）

> 接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）

### 解决粘包的方法

> 为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据

### 补充问题：为何tcp是可靠传输，udp是不可靠传输

> tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的。

> 而udp发送数据，对端是不会返回确认信息的，因此不可靠。
### 官网地址

> https://www.rabbitmq.com/getstarted.html

### **一、简单模式**

![image-20220725153422116](https://picture-typora-bucket.oss-cn-shanghai.aliyuncs.com/typora/image-20220725153422116.png)

一对一，一个生产者，一个消费者。一边塞，一边取。

**参数一，消息确认机制**：

> auto_ack=False 和 ch.basic_ack(delivery_tag=method.delivery_tag)套用

消费者中有一个监听队列的函数basic_consume，它里面有个参数auto_ack，如果为True就是自动应答，即MQ会把消费者拿掉的这个消息马上删除。这样会有问题，消费者这边监听函数肯定是正常取消息，如果万一回调函数callback崩了，相当于操作消息失败，想要再去MQ拿，就拿不到了。为了避免这个问题出现，我们必须用auto_ack=False，意思就是手动应答，即MQ必须收到消费者端的成功应答，才会把这个消息删除，否则就一直备份着。所以就在回调函数的最后应答ch.basic_ack(delivery_tag=method.delivery_tag)。这样做可以允许消费者端的回调函数出bug，debug后，再次取用消息进行操作，算是个防止消息丢失的方法。

**参数二，消息持久化机制**：

> durable=True 和 properties=pika.BasicProperties(delivery_mode=2)套用

MQ存储的所有消息都是在内存，只要MQ服务器宕机，消息全丢失。为了解决这个问题，引入了消息持久化，创建队列时加上durable=True，就能创建持久化队列。即该队列中的所有消息不再存于内存中，全部持久化到磁盘，相比不加，能最大程度保证消息不丢失。方法：创建队列时加上durable=True，然后给队列塞消息时加上properties=pika.BasicProperties(delivery_mode=2)。注意，队列不能由持久化变为普通队列，反之亦然，否则会报错。持久化存储存到磁盘会占空间，并且肯定是比内存慢，所以不是所有队列都要创建为持久化队列，一般只是把重要的消息塞进持久化队列中而已。

### **二、Work模式**

![image-20220725154053728](https://picture-typora-bucket.oss-cn-shanghai.aliyuncs.com/typora/image-20220725154053728.png)

顾名思义，就是工作模式，通常会把这个Work模式跟简单模式统称为简单模式。因为它们都没有使用到exchange交换机(exchange为空)。只不过这个Work模式是一个生产者P，对应多个消费者，多个消费者同时监听这一个队列。那到底怎么分配消息呢，MQ的Work模式默认是平均分配，就会引发问题，因为每个消费者处理消息的效率肯定是不同的，队列是先进先出，比如，第一个消息出来，分给第一个消费者，这个消费者马上处理完了，然后第二个消息就能出队列，再给到第二个消费者，要是这个消费者的cpu很垃圾的话，就会导致队列中后面的消息全出不来，一直等第二个消费者把第二个消息处理完，所以我们需要在每个消费者端配置一句话channel.basic_qos(prefetch_count=1)，表示谁处理完谁来拿消息处理，就不分你我，大家共同目的就是早处理完消息，你可以在消费者端的回调函数中进行time.sleep()验证。



Work模式的代码跟简单模式一样，实验的话，就跑多次消费者端代码就行了。但是直接跑不会重新开启新的控制台，需要配置pycharm工具栏---->run---->Edit Configurations---->Allow parallal run（在右上角的位置）

### **三、发布订阅模式(fanout)模式**

![image-20220725163646578](https://picture-typora-bucket.oss-cn-shanghai.aliyuncs.com/typora/image-20220725163646578.png)

> 在RabbitMQ中划分成了三种模式。发布订阅，关键字，模糊匹配。这三种模式，生产者不再创建队列，只创建交换机，生产者只往交换机里边塞消息，由交换机来向绑定了交换机的队列转发消息，所以消费者端必须创建队列，然后同时还要为自己创建的队列绑定

### **四、关键字(direct)模式**

![image-20220725172523031](https://picture-typora-bucket.oss-cn-shanghai.aliyuncs.com/typora/image-20220725172523031.png)

> 前面的发布订阅，为随机队列绑定交换机时，routing_key为空，即只要是绑定了交换机的队列就能收到消息，而这个关键字模式，仅仅是多了个关键字，相当于是细化了exchange转发消息的条件，现在就变成这样了，消费者端创建随机队列后，给队列绑定交换机时，传一个routing_key给交换机，然后生产者端发送消息给交换机时，也给交换机一个routing_key，只有双方给交换机的关键字暗号对的上，交换机才会转发消息给队列。仅仅是多了个关键字绑定，当然肯定不局限于一个关键字 ，消费者和生产者都可以绑定多个关键字。关键字模式是或的关系不是且，只要双方对得上一个关键字就算匹配成功。提一下简单模式和Work模式，它们的routing_key里面放的是队列名，并不是关键字，因为它们根本就没有exchange的概念，直接通过队列来通信没有中间这一层交换机。

### **五、模糊匹配(topic)模式**

![image-20220725173647410](https://picture-typora-bucket.oss-cn-shanghai.aliyuncs.com/typora/image-20220725173647410.png)

场景最多的就是fanout和direct模式，基本没人会用这个topic模式，发布订阅fanout模式是没有关键字只要绑定就转发。关键字direct模式是绑定一个或多个关键字，只要有一个关键字对的上就转发。而现在，这个模糊匹配就是在关键字模式上又做了个升级，即关键字不写死，两方都可以通过通配符来设置routing_key的值。#匹配0个或多个单词，*只匹配一个单词，a和abc都叫做一个单词。

### **六、用RabbitMQ实现RPC模式**

![image-20220725175915477](https://picture-typora-bucket.oss-cn-shanghai.aliyuncs.com/typora/image-20220725175915477.png)

> RPC——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议，和RabbitMQ没有必然关系，RPC可以基于tcp或http，http是基于tcp的，RPC直接工作在会话层。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使分布式系统中的应用程序通信更加容易，RPC采用C/S模式。在MQ的RPC模式中：客户端和服务器两边都在生产消息也在监听队列，客户端启动时，它将创建一个回调队列(可以是个随机队列，就是上图下方的reply_to那个队列)，对于RPC请求，客户端发送一条消息，该消息中要带上两个属性： reply_to(回调队列，告诉服务器端你把结果给我放进我的创建的这个回调队列)和correlation_id(请求的唯一标识)，塞进rpc_queue队列。服务器端正在监听。出现消息后，服务器端处理消息再把响应数据以及correlation_id按照reply_to字段中的指向，塞进那个回调队列。客户端监听这个回调队列，回调队列出现消息后，客户端将检查correlation_id与它请求时带的值是否一致，一致的话说明正是客户端这次RPC请求的响应结果。这儿RPC模式它怪就怪在这儿，发起RPC请求的一方能通过跟服务器商量，让服务器按要求把响应数据返回回来。RPC基本会用在公司内部系统上下游的应用程序通信，因为传输文件不能过大，所以对外基本是使用http的restful接口。用RabbitMQ来实现RPC模式，下面案例的目标就是客户端想用RPC请求调用另一台机上的fun函数，并且还要拿到响应结果。

### exchange模式和非exchange模式梳理

> 简单模式是一对一，一个消费者监听一个队列。Work模式是一对多，多个消费者监听同一个队列，统称为非exchange模式，缺点就是生产者的所有消息全堆积到同一个队列中，没有做消息分类。fanout，direct和topic统称为exchange模式或交换机模式，该模式下的每个消费者都有自己创建的队列，采用三种方式中的任意一种来绑定交换机，再由交换机分配消息给这些队列。exchange模式除了可以应对多个消费者之外，还可以应对消息多样化，因为MQ不知道这个消息到底分给哪个消费者来做，比如一个项目里面，有发送邮件，有发送支付短信，有赠送优惠券，这就是三类消息，使用exchange模式就很好应对，生产者和消费者两端商量好，双方都用send_email作为关键字，来表明这个是发邮件的消息，那交换机就会按照send_email去找队列，就完成了该队列只用于存放邮箱地址。其他类的消息双方又商量同时用另外一个关键字。应用场景最多的就是发布订阅和关键字模式。

### 参考网站

> https://www.cnblogs.com/hls91/p/15309641.html





